use std::mem;

use crate::U64Ext;

pub fn add(lhs: &mut [u64], rhs: &[u64], mut carry: bool) -> bool {
    for (lhs_digit, &rhs_digit) in lhs.iter_mut().zip(rhs) {
        (*lhs_digit, carry) = lhs_digit.carrying_add_ext(rhs_digit, carry);
    }
    for digit in lhs.get_mut(rhs.len()..).unwrap_or_default() {
        if !carry {
            return false;
        }
        (*digit, carry) = digit.overflowing_add(1);
    }
    carry
}

pub fn sub(lhs: &mut [u64], rhs: &[u64], mut borrow: bool) -> bool {
    for (lhs_digit, &rhs_digit) in lhs.iter_mut().zip(rhs) {
        (*lhs_digit, borrow) = lhs_digit.borrowing_sub_ext(rhs_digit, borrow);
    }
    for digit in lhs.get_mut(rhs.len()..).unwrap_or_default() {
        if !borrow {
            return false;
        }
        (*digit, borrow) = digit.overflowing_sub(1);
    }
    borrow
}

pub fn basic_inplace_mul(lhs: &mut [u64], lhs_len: usize, rhs: &[u64]) {
    if lhs_len == 0 {
        return;
    }
    let init_lhs = lhs;
    let lhs = &mut init_lhs[lhs_len - 1..];

    let factor = mem::take(&mut lhs[0]);
    let (mut carry, mut carry_bit) = (0, false);
    for (lhs, &rhs) in lhs.iter_mut().zip(rhs) {
        (*lhs, carry_bit) = lhs.carrying_add_ext(carry, carry_bit);
        (*lhs, carry) = factor.carrying_mul_ext(rhs, *lhs);
    }
    assert!(!add(&mut lhs[rhs.len()..], &[carry], carry_bit));
    basic_inplace_mul(init_lhs, lhs_len - 1, rhs)
}

pub fn basic_mul(dst: &mut [u64], lhs: &[u64], rhs: &[u64]) {
    for (i, &lhs) in lhs.iter().enumerate() {
        let (mut carry, mut carry_bit) = (0, false);
        for (dst, &rhs) in dst[i..].iter_mut().zip(rhs) {
            (*dst, carry_bit) = dst.carrying_add_ext(carry, carry_bit);
            (*dst, carry) = lhs.carrying_mul_ext(rhs, *dst);
        }
        assert!(!add(&mut dst[i + rhs.len()..], &[carry], carry_bit));
    }
}

pub fn karatsuba_mul(dst: &mut [u64], lhs: &[u64], rhs: &[u64]) {
    let max_len = lhs.len().max(rhs.len()) + 1;
    if lhs.is_empty() || rhs.is_empty() {
        return;
    } else if max_len < 6 {
        return basic_mul(dst, lhs, rhs);
    }

    let mid = max_len / 2;
    let (lhs0, lhs1) = lhs.split_at(mid.min(lhs.len()));
    let (rhs0, rhs1) = rhs.split_at(mid.min(rhs.len()));

    let mut buf = vec![0; max_len + 2];

    let (lhs_sum, rhs_sum) = buf.split_at_mut(mid + 1);
    let lhs_sum = &mut lhs_sum[..=lhs0.len().max(lhs1.len())];
    let rhs_sum = &mut rhs_sum[..=rhs0.len().max(rhs1.len())];

    lhs_sum[..lhs0.len()].copy_from_slice(lhs0);
    add(lhs_sum, lhs1, false);

    rhs_sum[..rhs0.len()].copy_from_slice(rhs0);
    add(rhs_sum, rhs1, false);

    karatsuba_mul(&mut dst[mid..], lhs_sum, rhs_sum);

    let mul0 = &mut buf[..lhs0.len() + rhs0.len()];
    mul0.fill(0);
    karatsuba_mul(mul0, lhs0, rhs0);
    add(dst, mul0, false);
    sub(&mut dst[mid..], mul0, false);

    let mul1 = &mut buf[..lhs1.len() + rhs1.len()];
    mul1.fill(0);
    karatsuba_mul(mul1, lhs1, rhs1);
    add(&mut dst[2 * mid..], mul1, false);
    sub(&mut dst[mid..], mul1, false);
}

#[allow(unused)]
pub fn toom3_mul(dst: &mut [u64], lhs: &[u64], rhs: &[u64]) {
    // p(x) = l2*x^2 + l1*x + l0, q(x) = r2*x^2 + r1*x + r0
    // lhs = p(B) = l2*B^2 + l1*B + l0, rhs = p(Q) = r2*B^2 + r1*B + r0
    // s(x) = p(x)*q(x) = s4*x^4 + s3*x^3 + s2*x^2 + s1*x + s0
    //
    // s(0) = s0 = l0*r0
    // s(1) = s4+s3+s2+s1+s0 = p(1)*q(1) = (l2+l1+l0)*(r2+r1+r0)
    // s(-1) = s4-s3+s2-s1+s0 = p(-1)*q(-1) = (l2-l1+l0)*(r2-r1+r0)
    // s(-2) = 16*s4 - 8*s3 + 4*s2 - 2*s1 + s0 = p(-2)*q(-2) = (4*l2 - 2*l1 + l0)*(4*r2 - 2*r1 + r0)
    // "s(inf)" = lim_{x->inf} s(x)/x^deg(s) = s4 = l2*r2
    //
    // s0 = s(0)
    // s1 =  s(0)/2 + s(1)/3 - s(-1)   + s(-2)/6 - 2*"s(inf)"
    // s2 = -s(0)   + s(1)/2 + s(-1)/2           -   "s(inf)"
    // s3 = -s(0)/2 + s(1)/6 + s(-1)/2 + s(-2)/6 + 2*"s(inf)"
    // s4 = "s(inf)"
    //
    // s(B) = s4*B^4 + s3*B^3 + s2*B^2 + s1*B + s0 = p(B)*q(B) = lhs*rhs

    let max_len = lhs.len().max(rhs.len()) + 1;
    if max_len < 81 {
        return karatsuba_mul(dst, lhs, rhs);
    }
    let section = max_len / 3 + 1;

    // Splitting

    let (lhs0, lhs12) = lhs.split_at(section.min(lhs.len()));
    let (lhs1, lhs2) = lhs12.split_at(section.min(lhs12.len()));

    let (rhs0, rhs12) = rhs.split_at(section.min(rhs.len()));
    let (rhs1, rhs2) = rhs12.split_at(section.min(rhs12.len()));

    // Evaluation & Pointwise-Multiplication
    let mut s_of_0 = vec![0; lhs0.len() + rhs0.len()];
    toom3_mul(&mut s_of_0, lhs0, rhs0);

    let mut s_of_1 = vec![0; lhs0.len() + rhs0.len() + 1];

    let mut lhs_sum = vec![0; lhs0.len() + rhs0.len()];

    toom3_mul(&mut s_of_1, lhs, rhs);

    todo!()
}

pub fn schÃ¶nhage_strassen_mul() {
    todo!()
}
